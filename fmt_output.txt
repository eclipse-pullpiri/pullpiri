Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:5:
 
 //! gRPC Server implementation for API Server clustering service
 
[32m+use crate::cluster::{NodeInfo, NodeRegistry, NodeResources, NodeRole, NodeStatus};
[m use common::apiserver::{
     api_server_service_server::{ApiServerService, ApiServerServiceServer},
     *,
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:11:
 };
[31m-use crate::cluster::{NodeRegistry, NodeInfo, NodeRole, NodeStatus, NodeResources};
[m use tokio::sync::OnceCell;
 use tonic::{Request, Response, Status};
 
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:19:
 /// Initialize the clustering gRPC service
 pub async fn initialize_clustering_service() -> Result<(), Box<dyn std::error::Error>> {
     let registry = NodeRegistry::new();
[31m-    registry.initialize().await
[m[32m+    registry
[m[32m+        .initialize()
[m[32m+        .await
[m         .map_err(|e| format!("Failed to initialize node registry: {}", e))?;
 
[31m-    NODE_REGISTRY.set(registry)
[m[32m+    NODE_REGISTRY
[m[32m+        .set(registry)
[m         .map_err(|_| "Failed to set global node registry")?;
 
     // Start background task for checking stale nodes
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:56:
         &self,
         request: Request<GetNodesRequest>,
     ) -> Result<Response<GetNodesResponse>, Status> {
[31m-        let registry = get_node_registry()
[m[31m-            .ok_or_else(|| Status::internal("Node registry not initialized"))?;
[m[32m+        let registry =
[m[32m+            get_node_registry().ok_or_else(|| Status::internal("Node registry not initialized"))?;
[m 
         let req = request.into_inner();
[31m-        let nodes = registry.get_all_nodes().await
[m[32m+        let nodes = registry
[m[32m+            .get_all_nodes()
[m[32m+            .await
[m             .map_err(|e| Status::internal(format!("Failed to get nodes: {}", e)))?;
 
         // Apply filters if provided
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:69:
             .filter(|node| {
                 if let Some(filter) = &req.filter {
                     // Simple filter implementation - can be extended
[31m-                    node.node_name.contains(filter) || 
[m[31m-                    node.ip_address.contains(filter)
[m[32m+                    node.node_name.contains(filter) || node.ip_address.contains(filter)
[m                 } else {
                     true
                 }
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:88:
         &self,
         request: Request<GetNodeRequest>,
     ) -> Result<Response<GetNodeResponse>, Status> {
[31m-        let registry = get_node_registry()
[m[31m-            .ok_or_else(|| Status::internal("Node registry not initialized"))?;
[m[32m+        let registry =
[m[32m+            get_node_registry().ok_or_else(|| Status::internal("Node registry not initialized"))?;
[m 
         let req = request.into_inner();
         match registry.get_node(&req.node_id).await {
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:99:
                     node: Some(grpc_node),
                 }))
             }
[31m-            Err(_) => Err(Status::not_found("Node not found"))
[m[32m+            Err(_) => Err(Status::not_found("Node not found")),
[m         }
     }
 
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:108:
         &self,
         request: Request<NodeRegistrationRequest>,
     ) -> Result<Response<NodeRegistrationResponse>, Status> {
[31m-        let registry = get_node_registry()
[m[31m-            .ok_or_else(|| Status::internal("Node registry not initialized"))?;
[m[32m+        let registry =
[m[32m+            get_node_registry().ok_or_else(|| Status::internal("Node registry not initialized"))?;
[m 
         let req = request.into_inner();
 
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:127:
 
         let mut node_info = NodeInfo::new(req.node_id.clone(), req.hostname, req.ip_address);
         node_info.role = role;
[31m-        
[m[32m+
[m         if let Some(resources) = req.resources {
             node_info.resources = NodeResources {
                 cpu_cores: resources.cpu_cores,
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:139:
         }
 
         match registry.register_node(node_info).await {
[31m-            Ok(cluster_id) => {
[m[31m-                Ok(Response::new(NodeRegistrationResponse {
[m[31m-                    success: true,
[m[31m-                    message: "Node registered successfully".to_string(),
[m[31m-                    cluster_id,
[m[31m-                }))
[m[31m-            }
[m[31m-            Err(e) => {
[m[31m-                Ok(Response::new(NodeRegistrationResponse {
[m[31m-                    success: false,
[m[31m-                    message: format!("Failed to register node: {}", e),
[m[31m-                    cluster_id: String::new(),
[m[31m-                }))
[m[31m-            }
[m[32m+            Ok(cluster_id) => Ok(Response::new(NodeRegistrationResponse {
[m[32m+                success: true,
[m[32m+                message: "Node registered successfully".to_string(),
[m[32m+                cluster_id,
[m[32m+            })),
[m[32m+            Err(e) => Ok(Response::new(NodeRegistrationResponse {
[m[32m+                success: false,
[m[32m+                message: format!("Failed to register node: {}", e),
[m[32m+                cluster_id: String::new(),
[m[32m+            })),
[m         }
     }
 
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:161:
         &self,
         _request: Request<GetTopologyRequest>,
     ) -> Result<Response<GetTopologyResponse>, Status> {
[31m-        let registry = get_node_registry()
[m[31m-            .ok_or_else(|| Status::internal("Node registry not initialized"))?;
[m[32m+        let registry =
[m[32m+            get_node_registry().ok_or_else(|| Status::internal("Node registry not initialized"))?;
[m 
         match registry.get_cluster_topology("default").await {
             Ok(topology) => {
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:171:
                     topology: Some(grpc_topology),
                 }))
             }
[31m-            Err(e) => Err(Status::internal(format!("Failed to get cluster topology: {}", e)))
[m[32m+            Err(e) => Err(Status::internal(format!(
[m[32m+                "Failed to get cluster topology: {}",
[m[32m+                e
[m[32m+            ))),
[m         }
     }
 
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:181:
         request: Request<UpdateTopologyRequest>,
     ) -> Result<Response<UpdateTopologyResponse>, Status> {
         let _req = request.into_inner();
[31m-        
[m[32m+
[m         // For now, return not implemented
         // This would need to be implemented based on specific requirements
         Err(Status::unimplemented("Topology update not yet implemented"))
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:225:
         cluster_name: topology.cluster_name,
         r#type: match topology.topology_type {
             crate::cluster::TopologyType::Simple => common::apiserver::TopologyType::Simple as i32,
[31m-            crate::cluster::TopologyType::Hierarchical => common::apiserver::TopologyType::Hierarchical as i32,
[m[32m+            crate::cluster::TopologyType::Hierarchical => {
[m[32m+                common::apiserver::TopologyType::Hierarchical as i32
[m[32m+            }
[m             crate::cluster::TopologyType::Mesh => common::apiserver::TopologyType::Mesh as i32,
             crate::cluster::TopologyType::Hybrid => common::apiserver::TopologyType::Hybrid as i32,
         },
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:232:
[31m-        master_nodes: topology.master_nodes.into_iter().map(convert_node_info_to_grpc).collect(),
[m[31m-        sub_nodes: topology.sub_nodes.into_iter().map(convert_node_info_to_grpc).collect(),
[m[32m+        master_nodes: topology
[m[32m+            .master_nodes
[m[32m+            .into_iter()
[m[32m+            .map(convert_node_info_to_grpc)
[m[32m+            .collect(),
[m[32m+        sub_nodes: topology
[m[32m+            .sub_nodes
[m[32m+            .into_iter()
[m[32m+            .map(convert_node_info_to_grpc)
[m[32m+            .collect(),
[m         config: topology.config,
     }
 }
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:252:
 
     Ok(())
 }
[32m+
[mDiff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/route/mod.rs:29:
         .allow_methods(Any)
         .allow_headers(Any);
 
[31m-    let app = Router::new()
[m[31m-        .merge(api::router())
[m[31m-        .layer(cors);
[m[32m+    let app = Router::new().merge(api::router()).layer(cors);
[m 
     println!("http api listening on {}", listener.local_addr().unwrap());
     axum::serve(listener, app).await.unwrap();
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:5:
 
 //! gRPC Server implementation for API Server clustering service
 
[32m+use crate::cluster::{NodeInfo, NodeRegistry, NodeResources, NodeRole, NodeStatus};
[m use common::apiserver::{
     api_server_service_server::{ApiServerService, ApiServerServiceServer},
     *,
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:11:
 };
[31m-use crate::cluster::{NodeRegistry, NodeInfo, NodeRole, NodeStatus, NodeResources};
[m use tokio::sync::OnceCell;
 use tonic::{Request, Response, Status};
 
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:19:
 /// Initialize the clustering gRPC service
 pub async fn initialize_clustering_service() -> Result<(), Box<dyn std::error::Error>> {
     let registry = NodeRegistry::new();
[31m-    registry.initialize().await
[m[32m+    registry
[m[32m+        .initialize()
[m[32m+        .await
[m         .map_err(|e| format!("Failed to initialize node registry: {}", e))?;
 
[31m-    NODE_REGISTRY.set(registry)
[m[32m+    NODE_REGISTRY
[m[32m+        .set(registry)
[m         .map_err(|_| "Failed to set global node registry")?;
 
     // Start background task for checking stale nodes
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:56:
         &self,
         request: Request<GetNodesRequest>,
     ) -> Result<Response<GetNodesResponse>, Status> {
[31m-        let registry = get_node_registry()
[m[31m-            .ok_or_else(|| Status::internal("Node registry not initialized"))?;
[m[32m+        let registry =
[m[32m+            get_node_registry().ok_or_else(|| Status::internal("Node registry not initialized"))?;
[m 
         let req = request.into_inner();
[31m-        let nodes = registry.get_all_nodes().await
[m[32m+        let nodes = registry
[m[32m+            .get_all_nodes()
[m[32m+            .await
[m             .map_err(|e| Status::internal(format!("Failed to get nodes: {}", e)))?;
 
         // Apply filters if provided
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:69:
             .filter(|node| {
                 if let Some(filter) = &req.filter {
                     // Simple filter implementation - can be extended
[31m-                    node.node_name.contains(filter) || 
[m[31m-                    node.ip_address.contains(filter)
[m[32m+                    node.node_name.contains(filter) || node.ip_address.contains(filter)
[m                 } else {
                     true
                 }
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:88:
         &self,
         request: Request<GetNodeRequest>,
     ) -> Result<Response<GetNodeResponse>, Status> {
[31m-        let registry = get_node_registry()
[m[31m-            .ok_or_else(|| Status::internal("Node registry not initialized"))?;
[m[32m+        let registry =
[m[32m+            get_node_registry().ok_or_else(|| Status::internal("Node registry not initialized"))?;
[m 
         let req = request.into_inner();
         match registry.get_node(&req.node_id).await {
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:99:
                     node: Some(grpc_node),
                 }))
             }
[31m-            Err(_) => Err(Status::not_found("Node not found"))
[m[32m+            Err(_) => Err(Status::not_found("Node not found")),
[m         }
     }
 
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:108:
         &self,
         request: Request<NodeRegistrationRequest>,
     ) -> Result<Response<NodeRegistrationResponse>, Status> {
[31m-        let registry = get_node_registry()
[m[31m-            .ok_or_else(|| Status::internal("Node registry not initialized"))?;
[m[32m+        let registry =
[m[32m+            get_node_registry().ok_or_else(|| Status::internal("Node registry not initialized"))?;
[m 
         let req = request.into_inner();
 
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:127:
 
         let mut node_info = NodeInfo::new(req.node_id.clone(), req.hostname, req.ip_address);
         node_info.role = role;
[31m-        
[m[32m+
[m         if let Some(resources) = req.resources {
             node_info.resources = NodeResources {
                 cpu_cores: resources.cpu_cores,
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:139:
         }
 
         match registry.register_node(node_info).await {
[31m-            Ok(cluster_id) => {
[m[31m-                Ok(Response::new(NodeRegistrationResponse {
[m[31m-                    success: true,
[m[31m-                    message: "Node registered successfully".to_string(),
[m[31m-                    cluster_id,
[m[31m-                }))
[m[31m-            }
[m[31m-            Err(e) => {
[m[31m-                Ok(Response::new(NodeRegistrationResponse {
[m[31m-                    success: false,
[m[31m-                    message: format!("Failed to register node: {}", e),
[m[31m-                    cluster_id: String::new(),
[m[31m-                }))
[m[31m-            }
[m[32m+            Ok(cluster_id) => Ok(Response::new(NodeRegistrationResponse {
[m[32m+                success: true,
[m[32m+                message: "Node registered successfully".to_string(),
[m[32m+                cluster_id,
[m[32m+            })),
[m[32m+            Err(e) => Ok(Response::new(NodeRegistrationResponse {
[m[32m+                success: false,
[m[32m+                message: format!("Failed to register node: {}", e),
[m[32m+                cluster_id: String::new(),
[m[32m+            })),
[m         }
     }
 
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:161:
         &self,
         _request: Request<GetTopologyRequest>,
     ) -> Result<Response<GetTopologyResponse>, Status> {
[31m-        let registry = get_node_registry()
[m[31m-            .ok_or_else(|| Status::internal("Node registry not initialized"))?;
[m[32m+        let registry =
[m[32m+            get_node_registry().ok_or_else(|| Status::internal("Node registry not initialized"))?;
[m 
         match registry.get_cluster_topology("default").await {
             Ok(topology) => {
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:171:
                     topology: Some(grpc_topology),
                 }))
             }
[31m-            Err(e) => Err(Status::internal(format!("Failed to get cluster topology: {}", e)))
[m[32m+            Err(e) => Err(Status::internal(format!(
[m[32m+                "Failed to get cluster topology: {}",
[m[32m+                e
[m[32m+            ))),
[m         }
     }
 
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:181:
         request: Request<UpdateTopologyRequest>,
     ) -> Result<Response<UpdateTopologyResponse>, Status> {
         let _req = request.into_inner();
[31m-        
[m[32m+
[m         // For now, return not implemented
         // This would need to be implemented based on specific requirements
         Err(Status::unimplemented("Topology update not yet implemented"))
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:225:
         cluster_name: topology.cluster_name,
         r#type: match topology.topology_type {
             crate::cluster::TopologyType::Simple => common::apiserver::TopologyType::Simple as i32,
[31m-            crate::cluster::TopologyType::Hierarchical => common::apiserver::TopologyType::Hierarchical as i32,
[m[32m+            crate::cluster::TopologyType::Hierarchical => {
[m[32m+                common::apiserver::TopologyType::Hierarchical as i32
[m[32m+            }
[m             crate::cluster::TopologyType::Mesh => common::apiserver::TopologyType::Mesh as i32,
             crate::cluster::TopologyType::Hybrid => common::apiserver::TopologyType::Hybrid as i32,
         },
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:232:
[31m-        master_nodes: topology.master_nodes.into_iter().map(convert_node_info_to_grpc).collect(),
[m[31m-        sub_nodes: topology.sub_nodes.into_iter().map(convert_node_info_to_grpc).collect(),
[m[32m+        master_nodes: topology
[m[32m+            .master_nodes
[m[32m+            .into_iter()
[m[32m+            .map(convert_node_info_to_grpc)
[m[32m+            .collect(),
[m[32m+        sub_nodes: topology
[m[32m+            .sub_nodes
[m[32m+            .into_iter()
[m[32m+            .map(convert_node_info_to_grpc)
[m[32m+            .collect(),
[m         config: topology.config,
     }
 }
Diff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/grpc/server.rs:252:
 
     Ok(())
 }
[32m+
[mDiff in /home/runner/work/pullpiri/pullpiri/src/server/apiserver/src/route/mod.rs:29:
         .allow_methods(Any)
         .allow_headers(Any);
 
[31m-    let app = Router::new()
[m[31m-        .merge(api::router())
[m[31m-        .layer(cors);
[m[32m+    let app = Router::new().merge(api::router()).layer(cors);
[m 
     println!("http api listening on {}", listener.local_addr().unwrap());
     axum::serve(listener, app).await.unwrap();
